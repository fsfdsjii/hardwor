-- Converted using Mokiros's Model to Script Version 3
-- Converted string size: 7596 characters

local ScriptFunctions = {
function(script,require)
--Responsible for regening a player's humanoid's health

-- declarations
local Figure = script.Parent
local Head = Figure:WaitForChild("Head")
local Humanoid = Figure:WaitForChild("Humanoid")
local regening = false

-- regeneration
function regenHealth()
	if regening then return end
	regening = true
	
	while Humanoid.Health < Humanoid.MaxHealth do
		local s = wait(1)
		local health = Humanoid.Health
		if health > 0 and health < Humanoid.MaxHealth then
			local newHealthDelta = 0.01 * s * Humanoid.MaxHealth
			health = health + newHealthDelta
			Humanoid.Health = math.min(health,Humanoid.MaxHealth)
		end
	end
	
	if Humanoid.Health > Humanoid.MaxHealth then
		Humanoid.Health = Humanoid.MaxHealth
	end
	
	regening = false
end

Humanoid.HealthChanged:connect(regenHealth)
  
end,
function(script,require)
--Made by Luckymaxer

Tool = script.Parent
Handle = Tool:WaitForChild("Handle")

Players = game:GetService("Players")
Debris = game:GetService("Debris")
RunService = game:GetService("RunService")

DamageValues = {
	BaseDamage = 5,
	SlashDamage = 8,
	LungeDamage = 12
}

Damage = DamageValues.BaseDamage

Grips = {
	Up = CFrame.new(0, 0, 1.9, 1, 0, -0, 0, 0, 1, 0, -1, 0),
	Out = CFrame.new(0, 0, 2.125, 1, 0, 0, 0, 1, 0, 0, 0, 1)
}

Sounds = {
	Slash = Handle:WaitForChild("SwordSlash"),
	Lunge = Handle:WaitForChild("SwordLunge"),
	Unsheath = Handle:WaitForChild("Unsheath")
}

ToolEquipped = false

Tool.Grip = Grips.Up
Tool.Enabled = true

function TagHumanoid(humanoid, player)
	local Creator_Tag = Instance.new("ObjectValue")
	Creator_Tag.Name = "creator"
	Creator_Tag.Value = player
	Debris:AddItem(Creator_Tag, 2)
	Creator_Tag.Parent = humanoid
end

function UntagHumanoid(humanoid)
	for i, v in pairs(humanoid:GetChildren()) do
		if v:IsA("ObjectValue") and v.Name == "creator" then
			v:Destroy()
		end
	end
end

function Blow(Hit)
	if not Hit or not Hit.Parent or not CheckIfAlive() or not ToolEquipped then
		return
	end
	local RightArm = Character:FindFirstChild("Right Arm") or Character:FindFirstChild("RightHand")
	if not RightArm then
		return
	end
	local RightGrip = RightArm:FindFirstChild("RightGrip")
	if not RightGrip or (RightGrip.Part0 ~= Handle and RightGrip.Part1 ~= Handle) then
		return
	end
	local character = Hit.Parent
	if character == Character then
		return
	end
	local humanoid = character:FindFirstChild("Humanoid")
	if not humanoid or humanoid.Health == 0 then
		return
	end
	UntagHumanoid(humanoid)
	TagHumanoid(humanoid, Player)
	humanoid:TakeDamage(Damage)	
end


function Attack()
	Damage = DamageValues.SlashDamage
	Sounds.Slash:Play()
	local Anim = Instance.new("StringValue")
	Anim.Name = "toolanim"
	Anim.Value = "Slash"
	Anim.Parent = Tool
end

function Lunge()
	Damage = DamageValues.LungeDamage

	Sounds.Lunge:Play()

	local Anim = Instance.new("StringValue")
	Anim.Name = "toolanim"
	Anim.Value = "Lunge"
	Anim.Parent = Tool
	
	if CheckIfAlive() then
		local Force = Instance.new("BodyVelocity")
		Force.velocity = Vector3.new(0, 10, 0) 
		Force.maxForce = Vector3.new(0, 4000, 0)
		Debris:AddItem(Force, 0.4)
		Force.Parent = Torso
	end
	
	wait(0.2)
	Tool.Grip = Grips.Out
	wait(0.6)
	Tool.Grip = Grips.Up

	Damage = DamageValues.SlashDamage
end

Tool.Enabled = true
LastAttack = 0

function Activated()

	if not Tool.Enabled or not ToolEquipped or not CheckIfAlive() then
		return
	end

	Tool.Enabled = false

	Tick = RunService.Stepped:wait()

	if (Tick - LastAttack < 0.2) then
		Lunge()
	else
		Attack()
	end

	LastAttack = Tick

	--wait(0.5)

	Tool.Enabled = true
end

function CheckIfAlive()
	return (((Character and Character.Parent and Humanoid and Humanoid.Parent and Humanoid.Health > 0 and Torso and Torso.Parent) and true) or false)
end

function Equipped()
	Character = Tool.Parent
	Humanoid = Character:FindFirstChild("Humanoid")
	Torso = Character:FindFirstChild("Torso") or Character:FindFirstChild("UpperTorso")
	if not CheckIfAlive() then
		return
	end
	ToolEquipped = true
	Sounds.Unsheath:Play()
end

function Unequipped()
	Tool.Grip = Grips.Up
	ToolEquipped = false
end

Handle.Touched:connect(Activated)
Tool.Equipped:connect(Equipped)
Tool.Unequipped:connect(Unequipped)

Connection = Handle.Touched:connect(Blow)
end,
function(script,require)
Mouse_Icon = "rbxasset://textures/GunCursor.png"
Reloading_Icon = "rbxasset://textures/GunWaitCursor.png"

Tool = script.Parent

Mouse = nil

function UpdateIcon()
	if Mouse then
		Mouse.Icon = Tool.Enabled and Mouse_Icon or Reloading_Icon
	end
end

function OnEquipped(ToolMouse)
	Mouse = ToolMouse
	UpdateIcon()
end

Tool:GetPropertyChangedSignal("Enabled"):Connect(UpdateIcon)
Tool.Equipped:connect(OnEquipped)

end,
function(script,require)
local Figure = script.Parent
local Torso = Figure:WaitForChild("Torso")
local RightShoulder = Torso:WaitForChild("Right Shoulder")
local LeftShoulder = Torso:WaitForChild("Left Shoulder")
local RightHip = Torso:WaitForChild("Right Hip")
local LeftHip = Torso:WaitForChild("Left Hip")
local Neck = Torso:WaitForChild("Neck")
local Humanoid = Figure:WaitForChild("Humanoid")
local pose = "Standing"

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0
local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=180435571", weight = 9 },
				{ id = "http://www.roblox.com/asset/?id=180435792", weight = 1 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=180426354", weight = 10 } 
			}, 
	run = 	{
				{ id = "run.xml", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=125750702", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=180436148", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=180436334", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=178130996", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=182393478", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=129967390", weight = 10 } 
--				{ id = "slash.xml", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=129967478", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=128777973", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=128853357", weight = 10 } 
			},
	dance1 = {
				{ id = "http://www.roblox.com/asset/?id=182435998", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491037", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491065", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=182436842", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491248", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491277", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=182436935", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491368", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491423", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=129423131", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=129423030", weight = 10 } 
			},
}
local dances = {"dance1", "dance2", "dance3"}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance1 = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	-- check for config values
	local config = script:FindFirstChild(name)
	if (config ~= nil) then
--		print("Loading anims " .. name)
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
	--			print(name .. " [" .. idx .. "] " .. animTable[name][idx].anim.AnimationId .. " (" .. animTable[name][idx].weight .. ")")
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
--			print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)


for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.3

local toolTransitionTime = 0.1
local fallTransitionTime = 0.3
local jumpMaxLimbVelocity = 0.75

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end
	return oldAnim
end

function setAnimationSpeed(speed)
	if speed ~= currentAnimSpeed then
		currentAnimSpeed = speed
		currentAnimTrack:AdjustSpeed(currentAnimSpeed)
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then

		local repeatAnim = currentAnim
		-- return to idle if finishing an emote
		if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
			repeatAnim = "idle"
		end
		
		local animSpeed = currentAnimSpeed
		playAnimation(repeatAnim, 0.0, Humanoid)
		setAnimationSpeed(animSpeed)
	end
end

-- Preload animations
function playAnimation(animName, transitionTime, humanoid) 
		
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
--		print(animName .. " " .. idx .. " [" .. origRoll .. "]")
	local anim = animTable[animName][idx].anim

	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
	end

end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
--		print("Keyframe : ".. frameName)	
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 
		
		local roll = math.random(1, animTable[animName].totalWeight) 
		local origRoll = roll
		local idx = 1
		while (roll > animTable[animName][idx].weight) do
			roll = roll - animTable[animName][idx].weight
			idx = idx + 1
		end
--		print(animName .. " * " .. idx .. " [" .. origRoll .. "]")
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end


	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------


function onRunning(speed)
	if speed > 0.01 then
		playAnimation("walk", 0.1, Humanoid)
		if currentAnimInstance and currentAnimInstance.AnimationId == "http://www.roblox.com/asset/?id=180426354" then
			setAnimationSpeed(speed / 14.5)
		end
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil then
			playAnimation("idle", 0.1, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / 12.0)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

function onSwimming(speed)
	if speed > 0 then
		pose = "Running"
	else
		pose = "Standing"
	end
end

function getTool()	
	for _, kid in ipairs(Figure:GetChildren()) do
		if kid.className == "Tool" then return kid end
	end
	return nil
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

function animateTool()
	
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function moveSit()
	RightShoulder.MaxVelocity = 0.15
	LeftShoulder.MaxVelocity = 0.15
	RightShoulder:SetDesiredAngle(3.14 /2)
	LeftShoulder:SetDesiredAngle(-3.14 /2)
	RightHip:SetDesiredAngle(3.14 /2)
	LeftHip:SetDesiredAngle(-3.14 /2)
end

local lastTick = 0

function move(time)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = time - lastTick
  	lastTick = time

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.1, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
--		print("Wha " .. pose)
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	if (setAngles) then
		local desiredAngle = amplitude * math.sin(time * frequency)

		RightShoulder:SetDesiredAngle(desiredAngle + climbFudge)
		LeftShoulder:SetDesiredAngle(desiredAngle - climbFudge)
		RightHip:SetDesiredAngle(-desiredAngle)
		LeftHip:SetDesiredAngle(-desiredAngle)
	end

	-- Tool Animation handling
	local tool = getTool()
	if tool and tool:FindFirstChild("Handle") then
	
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = time + .3
		end

		if time > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- main program

-- initialize to idle
playAnimation("idle", 0.1, Humanoid)
pose = "Standing"

while Figure.Parent ~= nil do
	local _, time = wait(0.1)
	move(time)
end



end,
function(script,require)
---This server script creates the sounds and also exists so that it can be easily copied into an NPC and create sounds for that NPC. 
--Remove the local script if you copy this into an NPC.

function waitForChild(parent, childName)
	local child = parent:findFirstChild(childName)
	if child then return child end
	while true do
		child = parent.ChildAdded:wait()
		if child.Name==childName then return child end
	end
end

function newSound(name, id)
	local sound = Instance.new("Sound")
	sound.SoundId = id
	sound.Name = name
	sound.archivable = false
	sound.Parent = script.Parent.Head
	return sound
end

-- declarations

local sGettingUp = newSound("GettingUp", "rbxasset://sounds/action_get_up.mp3")
local sDied = newSound("Died", "rbxasset://sounds/uuhhh.mp3") 
local sFreeFalling = newSound("FreeFalling", "rbxasset://sounds/action_falling.mp3")
local sJumping = newSound("Jumping", "rbxasset://sounds/action_jump.mp3")
local sLanding = newSound("Landing", "rbxasset://sounds/action_jump_land.mp3")
local sSplash = newSound("Splash", "rbxasset://sounds/impact_water.mp3")
local sRunning = newSound("Running", "rbxasset://sounds/action_footsteps_plastic.mp3")
sRunning.Looped = true
local sSwimming = newSound("Swimming", "rbxasset://sounds/action_swim.mp3")
sSwimming.Looped = true
local sClimbing = newSound("Climbing", "rbxasset://sounds/action_footsteps_plastic.mp3")
sClimbing.Looped = true

local Figure = script.Parent
local Head = waitForChild(Figure, "Head")
local Humanoid = waitForChild(Figure, "Humanoid")
local hasPlayer = game.Players:GetPlayerFromCharacter(script.Parent)
local filteringEnabled = game.Workspace.FilteringEnabled

local prevState = "None"

-- functions

function onDied()
	stopLoopedSounds()
	sDied:Play()
end

local fallCount = 0
local fallSpeed = 0
function onStateFall(state, sound)
	fallCount = fallCount + 1
	if state then
		sound.Volume = 0
		sound:Play()
		Spawn( function()
			local t = 0
			local thisFall = fallCount
			while t < 1.5 and fallCount == thisFall do
				local vol = math.max(t - 0.3 , 0)
				sound.Volume = vol
				wait(0.1)
				t = t + 0.1
			end
		end)
	else
		sound:Stop()
	end
	fallSpeed = math.max(fallSpeed, math.abs(Head.Velocity.Y))
end


function onStateNoStop(state, sound)
	if state then
		sound:Play()
	end
end


function onRunning(speed)
	sClimbing:Stop()
	sSwimming:Stop()
	if (prevState == "FreeFall" and fallSpeed > 0.1) then
		local vol = math.min(1.0, math.max(0.0, (fallSpeed - 50) / 110))
		sLanding.Volume = vol
		sLanding:Play()
		fallSpeed = 0
	end
	if speed>0.5 then
		sRunning:Play()
		sRunning.Pitch = speed / 8.0
	else
		sRunning:Stop()
	end
	prevState = "Run"
end

function onSwimming(speed)
	if (prevState ~= "Swim" and speed > 0.1) then
		local volume = math.min(1.0, speed / 350)
		sSplash.Volume = volume
		sSplash:Play()
		prevState = "Swim"
	end
	sClimbing:Stop()
	sRunning:Stop()
	sSwimming.Pitch = 1.6
	sSwimming:Play()
end

function onClimbing(speed)
	sRunning:Stop()
	sSwimming:Stop()	
	if speed>0.01 then
		sClimbing:Play()
		sClimbing.Pitch = speed / 5.5
	else
		sClimbing:Stop()
	end
	prevState = "Climb"
end
-- connect up

function stopLoopedSounds()
	sRunning:Stop() 
	sClimbing:Stop()
	sSwimming:Stop()
end

if hasPlayer == nil then
	Humanoid.Died:connect(onDied)
	Humanoid.Running:connect(onRunning)
	Humanoid.Swimming:connect(onSwimming)
	Humanoid.Climbing:connect(onClimbing)
	Humanoid.Jumping:connect(function(state) onStateNoStop(state, sJumping) prevState = "Jump" end)
	Humanoid.GettingUp:connect(function(state) stopLoopedSounds() onStateNoStop(state, sGettingUp) prevState = "GetUp" end)
	Humanoid.FreeFalling:connect(function(state) stopLoopedSounds() onStateFall(state, sFreeFalling) prevState = "FreeFall" end)
	Humanoid.FallingDown:connect(function(state) stopLoopedSounds() end)
	Humanoid.StateChanged:connect(function(old, new) 
		if not (new.Name == "Dead" or 
				new.Name == "Running" or 
				new.Name == "RunningNoPhysics" or 
				new.Name == "Swimming" or 
				new.Name == "Jumping" or 
				new.Name == "GettingUp" or 
				new.Name == "Freefall" or 
				new.Name == "FallingDown") then
			stopLoopedSounds()
		end
	end)
end

end,
function(script,require)
--This local script will run only for the player whos character it is in. It's changes to the sounds will replicate as they are changes to the character.
-- util

function waitForChild(parent, childName)
	local child = parent:findFirstChild(childName)
	if child then return child end
	while true do
		child = parent.ChildAdded:wait()
		if child.Name==childName then return child end
	end
end


-- declarations

local Figure = script.Parent.Parent
local Head = waitForChild(Figure, "Head")
local Humanoid = waitForChild(Figure, "Humanoid")

local sGettingUp = waitForChild(Head, "GettingUp")
local sDied = waitForChild(Head, "Died") 
local sFreeFalling = waitForChild(Head, "FreeFalling")
local sJumping = waitForChild(Head, "Jumping")
local sLanding = waitForChild(Head, "Landing")
local sSplash = waitForChild(Head, "Splash")
local sRunning = waitForChild(Head, "Running")
sRunning.Looped = true
local sSwimming = waitForChild(Head, "Swimming")
sSwimming.Looped = true
local sClimbing =waitForChild(Head, "Climbing")
sClimbing.Looped = true

local prevState = "None"

-- functions

function onDied()
	stopLoopedSounds()
	sDied:Play()
end

local fallCount = 0
local fallSpeed = 0
function onStateFall(state, sound)
	fallCount = fallCount + 1
	if state then
		sound.Volume = 0
		sound:Play()
		Spawn( function()
			local t = 0
			local thisFall = fallCount
			while t < 1.5 and fallCount == thisFall do
				local vol = math.max(t - 0.3 , 0)
				sound.Volume = vol
				wait(0.1)
				t = t + 0.1
			end
		end)
	else
		sound:Stop()
	end
	fallSpeed = math.max(fallSpeed, math.abs(Head.Velocity.Y))
end


function onStateNoStop(state, sound)
	if state then
		sound:Play()
	end
end


function onRunning(speed)
	sClimbing:Stop()
	sSwimming:Stop()
	if (prevState == "FreeFall" and fallSpeed > 0.1) then
		local vol = math.min(1.0, math.max(0.0, (fallSpeed - 50) / 110))
		sLanding.Volume = vol
		sLanding:Play()
		fallSpeed = 0
	end
	if speed>0.5 then
		sRunning:Play()
		sRunning.Pitch = speed / 8.0
	else
		sRunning:Stop()
	end
	prevState = "Run"
end

function onSwimming(speed)
	if (prevState ~= "Swim" and speed > 0.1) then
		local volume = math.min(1.0, speed / 350)
		sSplash.Volume = volume
		sSplash:Play()
		prevState = "Swim"
	end
	sClimbing:Stop()
	sRunning:Stop()
	sSwimming.Pitch = 1.6
	sSwimming:Play()
end

function onClimbing(speed)
	sRunning:Stop()
	sSwimming:Stop()	
	if speed>0.01 then
		sClimbing:Play()
		sClimbing.Pitch = speed / 5.5
	else
		sClimbing:Stop()
	end
	prevState = "Climb"
end
-- connect up

function stopLoopedSounds()
	sRunning:Stop() 
	sClimbing:Stop()
	sSwimming:Stop()
end

Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Swimming:connect(onSwimming)
Humanoid.Climbing:connect(onClimbing)
Humanoid.Jumping:connect(function(state) onStateNoStop(state, sJumping) prevState = "Jump" end)
Humanoid.GettingUp:connect(function(state) stopLoopedSounds() onStateNoStop(state, sGettingUp) prevState = "GetUp" end)
Humanoid.FreeFalling:connect(function(state) stopLoopedSounds() onStateFall(state, sFreeFalling) prevState = "FreeFall" end)
Humanoid.FallingDown:connect(function(state) stopLoopedSounds() end)
Humanoid.StateChanged:connect(function(old, new) 
	if not (new.Name == "Dead" or 
			new.Name == "Running" or 
			new.Name == "RunningNoPhysics" or 
			new.Name == "Swimming" or 
			new.Name == "Jumping" or 
			new.Name == "GettingUp" or 
			new.Name == "Freefall" or 
			new.Name == "FallingDown") then
		stopLoopedSounds()
	end
end)


end,
function(script,require)
local Humanoid = script.Parent.Humanoid
local AllowOwnerAttack = true
local Halt = false
local OwnerName = "JJK83"
local Spawn = {"HERE I COME!","This... is the day I FIGHT!","Once again, in the world where I strike others.","FIGHT ME, or get attacked.","Defend yourself! AND NOW.","I spawn in here!","I'm IN."}
local Dying = {"Augh!","That must hurt...!","Ow","I'll have to attack better...","I'm DUMPED!","I'm BEAT.","H-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGH!","IT'S PAIN!","It's over for me!","I suffer that!","OWWWWWWWWWWIIIIIEEEEE!","UUHHH!"}
local During = {"Go run or fight, DECIDE if you can!","Waiting for something?","COME AND GET ME IF YOU CAN!","Defend yourself!","Come prepared!","Got choice on what to do?"}
local Wait120 = 0

function onDied()
	if script.Parent:FindFirstChild("Head") then
		game:GetService("Chat"):Chat(script.Parent.Head,Dying[math.random(1,#Dying)],Enum.ChatColor.White)
	end
	game:GetService("Debris"):AddItem(script.Parent,5)
end
Humanoid.Died:connect(onDied)
function Chat(Message)
	if Humanoid.Health > 0 then
		if Message == script.Parent.Name..", attack all" then
			if AllowOwnerAttack == false or Halt == true then
				wait(2)
				game:GetService("Chat"):Chat(script.Parent.Head,"Got it. STAND BACK, "..OwnerName.."!",Enum.ChatColor.White)
				AllowOwnerAttack = true
				Halt = false
			else
				wait(2)
				game:GetService("Chat"):Chat(script.Parent.Head,"I'm already fighting like that! Still watch out, "..OwnerName..".",Enum.ChatColor.White)
			end
		elseif Message == script.Parent.Name..", attack others" then
			if AllowOwnerAttack == true or Halt == true then
				wait(2)
				game:GetService("Chat"):Chat(script.Parent.Head,"Got it! You may come closer, "..OwnerName..".",Enum.ChatColor.White)
				AllowOwnerAttack = false
				Halt = false
			else
				wait(2)
				game:GetService("Chat"):Chat(script.Parent.Head,"I'm already fighting like that. You can stay closer, "..OwnerName..".",Enum.ChatColor.White)
			end
		elseif Message == script.Parent.Name..", stop" then
			if Halt == false then
				wait(1)
				game:GetService("Chat"):Chat(script.Parent.Head,"Stopped, "..OwnerName..". Remember not to make contact with me.",Enum.ChatColor.White)
				Halt = true
				AllowOwnerAttack = false
				Humanoid.WalkToPoint = script.Parent:FindFirstChild("Head").Position
			else
				wait(1)
				game:GetService("Chat"):Chat(script.Parent.Head,"Already stopped, "..OwnerName..".",Enum.ChatColor.White)
			end
		end
	end
end

if game.Players:FindFirstChild(OwnerName) then
	game.Players:FindFirstChild(OwnerName).Chatted:connect(Chat)
end

function Join(player)
	if player.Name == OwnerName then
		player.Chatted:connect(Chat)
	end
end
game.Players.PlayerAdded:connect(Join)

wait(1)
game:GetService("Chat"):Chat(script.Parent.Head,Spawn[math.random(1,#Spawn)],Enum.ChatColor.White)

while true do
	wait(0.03)
	if not Humanoid then return end
	if Humanoid.Health <= 0 then return end
	script:ClearAllChildren()
	Wait120 = Wait120 + 1
	if Wait120 >= 120 then
		if Halt == false then
			game:GetService("Chat"):Chat(script.Parent.Head,During[math.random(1,#During)],Enum.ChatColor.White)
		else
			game:GetService("Chat"):Chat(script.Parent.Head,"...",Enum.ChatColor.White)
		end
		Wait120 = 0
	end
	if Halt == false then
		local Closest
		local CDist = math.huge
		local Children = game.Workspace:GetChildren()
		for i = 1,#Children do
			if Children[i].ClassName == "Model" and Children[i] ~= script.Parent and Children[i]:FindFirstChild("Humanoid") then
				if Children[i].Humanoid.Health > 0 then
					if not (AllowOwnerAttack == false and Children[i].Name == OwnerName) then
						local OValue = Instance.new("ObjectValue",script)
						OValue.Value = Children[i]
					end
				end
			end
		end
		Around = script:GetChildren()
		for i = 1,#Around do
			if Around[i].Value ~= nil then
				if Around[i].Value:FindFirstChildOfClass("Part") then
					local Dist = math.abs((Around[i].Value:FindFirstChildOfClass("Part").Position.X + Around[i].Value:FindFirstChildOfClass("Part").Position.Y + Around[i].Value:FindFirstChildOfClass("Part").Position.Z) - (script.Parent:FindFirstChildOfClass("Part").Position.X + script.Parent:FindFirstChildOfClass("Part").Position.Y + script.Parent:FindFirstChildOfClass("Part").Position.Z))
					if Dist < CDist then
						Closest = Around[i].Value:FindFirstChildOfClass("Part")
						CDist = Dist
					end
				end
			end
		end
		if Closest then
			local Points = game:GetService("PathfindingService"):ComputeRawPathAsync(Closest.Position,script.Parent:FindFirstChild("Head").Position,300)
			local Co = Points:GetPointCoordinates()
			if Points.Status == Enum.PathStatus.Success or Points.Status == Enum.PathStatus.ClosestNoPath or Points.Status == Enum.PathStatus.ClosestOutOfRange then
				if #Co >= 1 then
					Humanoid.WalkToPoint = Co[1] + Vector3.new(math.random(-2,2),math.random(-2,2),math.random(-2,2))
					if Co[1].Y > script.Parent:FindFirstChild("Head").Position.Y + 2 or Humanoid.Sit or Humanoid.PlatformStand then
						Humanoid.Jump = true
					end
				end
			end
		end
		wait(0.1)
		if Closest then
			Humanoid.WalkToPoint = Closest.Position + Vector3.new(math.random(-2,2),math.random(-2,2),math.random(-2,2))
			if not (Humanoid:GetState() == Enum.HumanoidStateType.Climbing or CDist > 4) and Closest.Position.Y > script.Parent:FindFirstChild("Head").Position.Y + 2 or Humanoid.Sit or Humanoid.PlatformStand then
				Humanoid.Jump = true
			end
		end
	end
end
end,
function(script,require)
local Clone = script.Parent.Parent.JJK83:Clone()
local Current = script.Parent.Parent.JJK83
local FF = Instance.new("ForceField",Current)
game.Debris:AddItem(FF)
Current.Parent = game.Workspace
while true do
	wait(0.1)
	if not Current or Current.Parent == nil then
		Current = Clone:Clone()
		Current.Parent = game.Workspace
		local FF = Instance.new("ForceField",Current)
		game.Debris:AddItem(FF)
		Current:MoveTo(script.Parent.Position)
	end
end
end
}
local ScriptIndex = 0
local Scripts,ModuleScripts,ModuleCache = {},{},{}
local _require = require
function require(obj,...)
	local index = ModuleScripts[obj]
	if not index then
		local a,b = pcall(_require,obj,...)
		return not a and error(b,2) or b
	end
	
	local res = ModuleCache[index]
	if res then return res end
	res = ScriptFunctions[index](obj,require)
	if res==nil then error("Module code did not return exactly one value",2) end
	ModuleCache[index] = res
	return res
end
local function Script(obj,ismodule)
	ScriptIndex = ScriptIndex + 1
	local t = ismodule and ModuleScripts or Scripts
	t[obj] = ScriptIndex
end

function RunScripts()
	for script,index in pairs(Scripts) do
		coroutine.wrap(ScriptFunctions[index])(script,require)
	end
end


local function Decode(str)
	local StringLength = #str
	
	-- Base64 decoding
	do
		local decoder = {}
		for b64code, char in pairs(('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='):split('')) do
			decoder[char:byte()] = b64code-1
		end
		local n = StringLength
		local t,k = table.create(math.floor(n/4)+1),1
		local padding = str:sub(-2) == '==' and 2 or str:sub(-1) == '=' and 1 or 0
		for i = 1, padding > 0 and n-4 or n, 4 do
			local a, b, c, d = str:byte(i,i+3)
			local v = decoder[a]*0x40000 + decoder[b]*0x1000 + decoder[c]*0x40 + decoder[d]
			t[k] = string.char(bit32.extract(v,16,8),bit32.extract(v,8,8),bit32.extract(v,0,8))
			k = k + 1
		end
		if padding == 1 then
			local a, b, c = str:byte(n-3,n-1)
			local v = decoder[a]*0x40000 + decoder[b]*0x1000 + decoder[c]*0x40
			t[k] = string.char(bit32.extract(v,16,8),bit32.extract(v,8,8))
		elseif padding == 2 then
			local a, b = str:byte(n-3,n-2)
			local v = decoder[a]*0x40000 + decoder[b]*0x1000
			t[k] = string.char(bit32.extract(v,16,8))
		end
		str = table.concat(t)
	end
	
	local Position = 1
	local function Parse(fmt)
		local Values = {string.unpack(fmt,str,Position)}
		Position = table.remove(Values)
		return table.unpack(Values)
	end
	
	local Settings = Parse('B')
	local Flags = Parse('B')
	Flags = {
		--[[ValueIndexByteLength]] bit32.extract(Flags,6,2)+1,
		--[[InstanceIndexByteLength]] bit32.extract(Flags,4,2)+1,
		--[[ConnectionsIndexByteLength]] bit32.extract(Flags,2,2)+1,
		--[[MaxPropertiesLengthByteLength]] bit32.extract(Flags,0,2)+1,
		--[[Use Double instead of Float]] bit32.band(Settings,0b1) > 0
	}
	
	local ValueFMT = ('I'..Flags[1])
	local InstanceFMT = ('I'..Flags[2])
	local ConnectionFMT = ('I'..Flags[3])
	local PropertyLengthFMT = ('I'..Flags[4])
	
	local ValuesLength = Parse(ValueFMT)
	local Values = table.create(ValuesLength)
	local CFrameIndexes = {}
	
	local ValueDecoders = {
		--!!Start
		[1] = function(Modifier)
			return Parse('s'..Modifier)
		end,
		--!!Split
		[2] = function(Modifier)
			return Modifier ~= 0
		end,
		--!!Split
		[3] = function()
			return Parse('d')
		end,
		--!!Split
		[4] = function(_,Index)
			table.insert(CFrameIndexes,{Index,Parse(('I'..Flags[1]):rep(3))})
		end,
		--!!Split
		[5] = {CFrame.new,Flags[5] and 'dddddddddddd' or 'ffffffffffff'},
		--!!Split
		[6] = {Color3.fromRGB,'BBB'},
		--!!Split
		[7] = {BrickColor.new,'I2'},
		--!!Split
		[8] = function(Modifier)
			local len = Parse('I'..Modifier)
			local kpts = table.create(len)
			for i = 1,len do
				kpts[i] = ColorSequenceKeypoint.new(Parse('f'),Color3.fromRGB(Parse('BBB')))
			end
			return ColorSequence.new(kpts)
		end,
		--!!Split
		[9] = function(Modifier)
			local len = Parse('I'..Modifier)
			local kpts = table.create(len)
			for i = 1,len do
				kpts[i] = NumberSequenceKeypoint.new(Parse(Flags[5] and 'ddd' or 'fff'))
			end
			return NumberSequence.new(kpts)
		end,
		--!!Split
		[10] = {Vector3.new,Flags[5] and 'ddd' or 'fff'},
		--!!Split
		[11] = {Vector2.new,Flags[5] and 'dd' or 'ff'},
		--!!Split
		[12] = {UDim2.new,Flags[5] and 'di2di2' or 'fi2fi2'},
		--!!Split
		[13] = {Rect.new,Flags[5] and 'dddd' or 'ffff'},
		--!!Split
		[14] = function()
			local flags = Parse('B')
			local ids = {"Top","Bottom","Left","Right","Front","Back"}
			local t = {}
			for i = 0,5 do
				if bit32.extract(flags,i,1)==1 then
					table.insert(t,Enum.NormalId[ids[i+1]])
				end
			end
			return Axes.new(unpack(t))
		end,
		--!!Split
		[15] = function()
			local flags = Parse('B')
			local ids = {"Top","Bottom","Left","Right","Front","Back"}
			local t = {}
			for i = 0,5 do
				if bit32.extract(flags,i,1)==1 then
					table.insert(t,Enum.NormalId[ids[i+1]])
				end
			end
			return Faces.new(unpack(t))
		end,
		--!!Split
		[16] = {PhysicalProperties.new,Flags[5] and 'ddddd' or 'fffff'},
		--!!Split
		[17] = {NumberRange.new,Flags[5] and 'dd' or 'ff'},
		--!!Split
		[18] = {UDim.new,Flags[5] and 'di2' or 'fi2'},
		--!!Split
		[19] = function()
			return Ray.new(Vector3.new(Parse(Flags[5] and 'ddd' or 'fff')),Vector3.new(Parse(Flags[5] and 'ddd' or 'fff')))
		end
		--!!End
	}
	
	for i = 1,ValuesLength do
		local TypeAndModifier = Parse('B')
		local Type = bit32.band(TypeAndModifier,0b11111)
		local Modifier = (TypeAndModifier - Type) / 0b100000
		local Decoder = ValueDecoders[Type]
		if type(Decoder)=='function' then
			Values[i] = Decoder(Modifier,i)
		else
			Values[i] = Decoder[1](Parse(Decoder[2]))
		end
	end
	
	for i,t in pairs(CFrameIndexes) do
		Values[t[1]] = CFrame.fromMatrix(Values[t[2]],Values[t[3]],Values[t[4]])
	end
	
	local InstancesLength = Parse(InstanceFMT)
	local Instances = {}
	local NoParent = {}
	
	for i = 1,InstancesLength do
		local ClassName = Values[Parse(ValueFMT)]
		local obj
		local MeshPartMesh,MeshPartScale
		if ClassName == "UnionOperation" then
			obj = DecodeUnion(Values,Flags,Parse)
			obj.UsePartColor = true
		elseif ClassName:find("Script") then
			obj = Instance.new("Folder")
			Script(obj,ClassName=='ModuleScript')
		elseif ClassName == "MeshPart" then
			obj = Instance.new("Part")
			MeshPartMesh = Instance.new("SpecialMesh")
			MeshPartMesh.MeshType = Enum.MeshType.FileMesh
			MeshPartMesh.Parent = obj
		else
			obj = Instance.new(ClassName)
		end
		local Parent = Instances[Parse(InstanceFMT)]
		local PropertiesLength = Parse(PropertyLengthFMT)
		local AttributesLength = Parse(PropertyLengthFMT)
		Instances[i] = obj
		for i = 1,PropertiesLength do
			local Prop,Value = Values[Parse(ValueFMT)],Values[Parse(ValueFMT)]
			
			-- ok this looks awful
			if MeshPartMesh then
				if Prop == "MeshId" then
					MeshPartMesh.MeshId = Value
					continue
				elseif Prop == "TextureID" then
					MeshPartMesh.TextureId = Value
					continue
				elseif Prop == "Size" then
					if not MeshPartScale then
						MeshPartScale = Value
					else
						MeshPartMesh.Scale = Value / MeshPartScale
					end
				elseif Prop == "MeshSize" then
					if not MeshPartScale then
						MeshPartScale = Value
						MeshPartMesh.Scale = obj.Size / Value
					else
						MeshPartMesh.Scale = MeshPartScale / Value
					end
					continue
				end
			end
			
			obj[Prop] = Value
		end
		if MeshPartMesh then
			if MeshPartMesh.MeshId=='' then
				if MeshPartMesh.TextureId=='' then
					MeshPartMesh.TextureId = 'rbxasset://textures/meshPartFallback.png'
				end
				MeshPartMesh.Scale = obj.Size
			end
		end
		for i = 1,AttributesLength do
			obj:SetAttribute(Values[Parse(ValueFMT)],Values[Parse(ValueFMT)])
		end
		if not Parent then
			table.insert(NoParent,obj)
		else
			obj.Parent = Parent
		end
	end
	
	local ConnectionsLength = Parse(ConnectionFMT)
	for i = 1,ConnectionsLength do
		local a,b,c = Parse(InstanceFMT),Parse(ValueFMT),Parse(InstanceFMT)
		Instances[a][Values[b]] = Instances[c]
	end
	
	return NoParent
end


local Objects = Decode('AEAyASEFTW9kZWwhBE5hbWUhEUpKSzgzJ3MgTlBDIFNwYXduIQpXb3JsZFBpdm90BBABEQE1ACEFSkpLODMhC1ByaW1hcnlQYXJ0BBIBEQE1ACEEUGFydCEESGVhZCEKQnJpY2tDb2xvcgcSACEGQ0ZyYW1lBBQAEQE1ACEFQ29sb3IGzI5pIQZMb2NrZWQiIQhQb3Np'
..'dGlvbgqFU0NCRgCwQMwABsIhBFNpemUKAAAAQAAAgD8AAIA/IQpUb3BTdXJmYWNlAwAAAAAAAAAAIQtTcGVjaWFsTWVzaCEFU2NhbGUKAACgPwAAoD8AAKA/IQpBdHRhY2htZW50IQ5IYWlyQXR0YWNobWVudAQfABEBNQAKAAAAAJqZGT8AAAAAIQ1IYXRBdHRhY2ht'
..'ZW50IRNGYWNlRnJvbnRBdHRhY2htZW50BCMAEQE1AAoAAAAAAAAAAJqZGb8hFEZhY2VDZW50ZXJBdHRhY2htZW50IQVEZWNhbCEEZmFjZSEHVGV4dHVyZSEqaHR0cDovL3d3dy5yb2Jsb3guY29tL2Fzc2V0Lz9pZD0xNDQwODA0OTUgIQVUb3JzbwdrAAQvABEBNQAG'
..'AI+cIQtMZWZ0U3VyZmFjZQMAAAAAAAAAQAqFU0NCRgCAQMwABsIhDFJpZ2h0U3VyZmFjZQoAAABAAAAAQAAAgD8hBnJvYmxveCEOTmVja0F0dGFjaG1lbnQENQARATUACgAAAAAAAIA/AAAAACETQm9keUZyb250QXR0YWNobWVudAQ4ABEBNQAKAAAAAAAAAAAAAAC/'
..'IRJCb2R5QmFja0F0dGFjaG1lbnQEOwARATUACgAAAAAAAAAAAAAAPyEUTGVmdENvbGxhckF0dGFjaG1lbnQEPgARATUACgAAgL8AAIA/AAAAACEVUmlnaHRDb2xsYXJBdHRhY2htZW50BEEAEQE1AAoAAIA/AACAPwAAAAAhFFdhaXN0RnJvbnRBdHRhY2htZW50BEQA'
..'EQE1AAoAAAAAAACAvwAAAL8hFVdhaXN0Q2VudGVyQXR0YWNobWVudARHABEBNQAKAAAAAAAAgL8AAAAAIRNXYWlzdEJhY2tBdHRhY2htZW50BEoAEQE1AAoAAAAAAACAvwAAAD8hB01vdG9yNkQhBE5lY2shAkMwBDUAEwEUASECQzEEFQETARQBIQVQYXJ0MCEFUGFy'
..'dDEhC01heFZlbG9jaXR5AwAAAKCZmbk/IQhMZWZ0IEhpcAQWARQBNQAEFwEUATUAIQlSaWdodCBIaXAEGAEZATUABBoBGQE1ACENTGVmdCBTaG91bGRlcgQbARQBNQAEHAEUATUAIQ5SaWdodCBTaG91bGRlcgQdARkBNQAEHgEZATUAIQhMZWZ0IEFybQRlABEBNQAh'
..'CkNhbkNvbGxpZGUCCoVTPUJGAIBAzAAGwgoAAIA/AAAAQAAAgD8hFkxlZnRTaG91bGRlckF0dGFjaG1lbnQhEkxlZnRHcmlwQXR0YWNobWVudCEJUmlnaHQgQXJtBGsAEQE1AAqFU0lCRgCAQMwABsIhF1JpZ2h0U2hvdWxkZXJBdHRhY2htZW50IRNSaWdodEdyaXBB'
..'dHRhY2htZW50IQRXZWxkIQlSaWdodEdyaXAERwARARkBBB8BEQEZASEITGVmdCBMZWchDUJvdHRvbVN1cmZhY2UHBwQEdwARATUABmIl0QqFU0FCjAAAQMwABsIhEkxlZnRGb290QXR0YWNobWVudCEJUmlnaHQgTGVnBHsAEQE1AAqFU0VCjAAAQMwABsIhE1JpZ2h0'
..'Rm9vdEF0dGFjaG1lbnQhCEh1bWFub2lkIQhBbmltYXRvciEQSHVtYW5vaWRSb290UGFydCEMVHJhbnNwYXJlbmN5AwAAAAAAAPA/IQ5Sb290QXR0YWNobWVudCEJUm9vdEpvaW50BCABEwEUASEGU2NyaXB0IQZIZWFsdGghCkJvZHlDb2xvcnMhCUhlYWRDb2xvciEK'
..'SGVhZENvbG9yMwbMjmkhDExlZnRBcm1Db2xvciENTGVmdEFybUNvbG9yMyEMTGVmdExlZ0NvbG9yIQ1MZWZ0TGVnQ29sb3IzBmIl0SENUmlnaHRBcm1Db2xvciEOUmlnaHRBcm1Db2xvcjMhDVJpZ2h0TGVnQ29sb3IhDlJpZ2h0TGVnQ29sb3IzIQpUb3Jzb0NvbG9y'
..'IQtUb3Jzb0NvbG9yMyEJQWNjZXNzb3J5IRNGdXR1cmlzdGljU3dvcmRwYWNrIQ9BdHRhY2htZW50UG9pbnQEmwARATUAIQ1BdHRhY2htZW50UG9zCgAAAAAzM7M/mpkZvyEGSGFuZGxlBJ4AIQEiAQqFU0NCejOTQB6aA8IKXI+iP9aj0D8AAIA/Cs3MjD/NzIw/zcyM'
..'PyEGTWVzaElkISpodHRwOi8vd3d3LnJvYmxveC5jb20vYXNzZXQvP2lkPTI0MzIzMDA1NyAhCVRleHR1cmVJZCEqaHR0cDovL3d3dy5yb2Jsb3guY29tL2Fzc2V0Lz9pZD0yNDMyMzAzNjAgIQhNZXNoVHlwZQMAAAAAAAAUQASqACMBJAEhC09yaWVudGF0aW9uCgAA'
..'AAAAAAAAT45GEAoAAAAAnJkZv5xbzb0hDUFjY2Vzc29yeVdlbGQhBkNhbWVyYSEPVGh1bWJuYWlsQ2FtZXJhBCUBJgEnASEFRm9jdXMEKAERATUAIQVQYW50cyENUGFudHNUZW1wbGF0ZSEpaHR0cDovL3d3dy5yb2Jsb3guY29tL2Fzc2V0Lz9pZD0yMzk5NTc3MTUh'
..'BVNoaXJ0IQ1TaGlydFRlbXBsYXRlISlodHRwOi8vd3d3LnJvYmxveC5jb20vYXNzZXQvP2lkPTE0ODU4NzI0NSEPQnJvd24gUm9ibG9odW5rBLkAEQE1AAoAAAAAzcxMPW8SA7sEuwApASoBCoVTQ0KsZr5AeP4FwgoAAIA/AACAPwAAAEAKZmaGP83MjD/NzIw/ISho'
..'dHRwOi8vd3d3LnJvYmxveC5jb20vYXNzZXQvP2lkPTE1NzMwNzEwIShodHRwOi8vd3d3LnJvYmxveC5jb20vYXNzZXQvP2lkPTIwNjQyNzExBMIAKwEsAQoQ4tUoePZhm38g8rQKAMAUMqCZGT7v6RS7IQxWZWN0b3IzVmFsdWUhDE9yaWdpbmFsU2l6ZSEFVmFsdWUh'
..'BFRvb2whC0FJS3Vib1N3b3JkBC0BEQE1AAfHAATMABEBNQAGY19iCoVTSUKMAEBAZpoNwgoAAAA/zcxMPwAAkEAKMzMzPzMzMz8zMzM/IRZyYnhhc3NldGlkOi8vNTQwNzgyODkxIRZyYnhhc3NldGlkOi8vNTQwNzgyOTc2IQVTb3VuZCEKU3dvcmRMdW5nZSEHU291'
..'bmRJZCEoaHR0cDovL3d3dy5yb2Jsb3guY29tL2Fzc2V0Lz9pZD0xMjIyMjIwOCEGVm9sdW1lAwAAAEAzM+M/IQpTd29yZFNsYXNoIShodHRwOi8vd3d3LnJvYmxveC5jb20vYXNzZXQvP2lkPTEyMjIyMjE2AwAAAGBmZuY/IQhVbnNoZWF0aCEoaHR0cDovL3d3dy5y'
..'b2Jsb3guY29tL2Fzc2V0Lz9pZD0xMjIyMjIyNQTeAC4BGQEKAAC0wgAAAIAAAAAACgAAAAAAAAAAMjPzPyELU3dvcmRTY3JpcHQhC0xvY2FsU2NyaXB0IQlNb3VzZUljb24ELwEwATEBBDIBEQE1ACEHQW5pbWF0ZSELU3RyaW5nVmFsdWUhBWNsaW1iIQlBbmltYXRp'
..'b24hCUNsaW1iQW5pbSELQW5pbWF0aW9uSWQhKWh0dHA6Ly93d3cucm9ibG94LmNvbS9hc3NldC8/aWQ9MTgwNDM2MzM0IQRmYWxsIQhGYWxsQW5pbSEpaHR0cDovL3d3dy5yb2Jsb3guY29tL2Fzc2V0Lz9pZD0xODA0MzYxNDghBGlkbGUhCkFuaW1hdGlvbjEhKWh0'
..'dHA6Ly93d3cucm9ibG94LmNvbS9hc3NldC8/aWQ9MTgwNDM1NTcxIQtOdW1iZXJWYWx1ZSEGV2VpZ2h0AwAAAAAAACJAIQpBbmltYXRpb24yISlodHRwOi8vd3d3LnJvYmxveC5jb20vYXNzZXQvP2lkPTE4MDQzNTc5MiEEanVtcCEISnVtcEFuaW0hKWh0dHA6Ly93'
..'d3cucm9ibG94LmNvbS9hc3NldC8/aWQ9MTI1NzUwNzAyIQNydW4hB1J1bkFuaW0hKWh0dHA6Ly93d3cucm9ibG94LmNvbS9hc3NldC8/aWQ9MTgwNDI2MzU0IQNzaXQhB1NpdEFuaW0hKWh0dHA6Ly93d3cucm9ibG94LmNvbS9hc3NldC8/aWQ9MTc4MTMwOTk2IQh0'
..'b29sbm9uZSEMVG9vbE5vbmVBbmltISlodHRwOi8vd3d3LnJvYmxveC5jb20vYXNzZXQvP2lkPTE4MjM5MzQ3OCEEd2FsayEIV2Fsa0FuaW0hCkxvY2FsU291bmQhAkFJIQ1TcGF3bkxvY2F0aW9uIQpJU3Bhd25IZXJlIQhBbmNob3JlZAQKAREBNQAKxQ1DQg8BAD8k'
..'6gXCCgAAwEAAAIA/AADAQCEHTmV1dHJhbCEERmFjZSElcmJ4YXNzZXQ6Ly90ZXh0dXJlcy9TcGF3bkxvY2F0aW9uLnBuZyEKUmVnZW5lcmF0ZQrFDUNCz2ZOQEVCCMIKAACAPwAAAAAAAAAACgSQbr++Zm5Ahz93QQoAAIC/AAAAAAAAAAAKAAAAAAAAAAAAAIA/CgAA'
..'AAAAAAC/AAAAAAoAAIC/AACAvwAAAAAKAAAAvwAAgD8AAAAACgAAgD8AAIC/AAAAAAoAAAAAAAAAAAAAgL8KAAAAPwAAgD8AAAAACgAAgL8AAAA/AAAAAAoAAAA/AAAAPwAAAAAKAACAPwAAAD8AAAAACgAAAL8AAAA/AAAAAAoAAAAAAAAAADMz8z8KAAAAAAAAAAAA'
..'AAAACgAAgD8Ayl2NAAAAAAoAyl0NAACAPwAAAAAKAACAPwDKXQ0AAAAACgDKXY0AAIA/AAAAAAr8f46/4N6AQancnUEKd5t1vwAAgLEwZ5A+CpzfJT3oWH0/BBANPgq8vOi+w1F8QbbJr0EKAACAP606BzIhZ3yYCq06B7IAAIA/4OjupQoAAIA/rToHsgAAAAAKrToH'
..'MgAAgD/g6O4lCqUwyELDAEBARcKrwgoAAIA/AAAAjwAAAAAKPqfKQMiFk0CXFva/CktWSL0AAACAkbF/vwr/zYG+pp13P7JnSzwKzNKMQA5Hg0At+um/WwEAAAIAAgADAAQABQABAAECAAIABgAEAAgACQACCAACAAoACwAMAA0ADgAPABAAEQASABMAFAAVABYAFwAY'
..'ABkAAwEAGgAbABwAAwMAAgAdAA0AHgATAB8AHAADAwACACAADQAeABMAHwAcAAMDAAIAIQANACIAEwAjABwAAwEAAgAkACUAAwIAAgAmACcAKAAJAAIJAAIAKQALACoADQArAA8ALAAtAC4AEQASABMALwAwAC4AFQAxACUACgEAAgAyABwACgMAAgAzAA0ANAATADUA'
..'HAAKAwACADYADQA3ABMAOAAcAAoDAAIAOQANADoAEwA7ABwACgMAAgA8AA0APQATAD4AHAAKAwACAD8ADQBAABMAQQAcAAoDAAIAQgANAEMAEwBEABwACgMAAgBFAA0ARgATAEcAHAAKAwACAEgADQBJABMASgBLAAoEAAIATABNAE4ATwBQAFMAVABLAAoEAAIAVQBN'
..'AFYATwBXAFMAVABLAAoEAAIAWABNAFkATwBaAFMAVABLAAoEAAIAWwBNAFwATwBdAFMAVABLAAoEAAIAXgBNAF8ATwBgAFMAVAAJAAIIAAIAYQALAAwADQBiAGMAZAAPABAAEQASABMAZQAVAGYAHAAZAwACAGcADQA0ABMANQAcABkDAAIAaAANAEYAEwBHAAkAAggA'
..'AgBpAAsADAANAGoAYwBkAA8AEAARABIAEwBrABUAZgAcABwDAAIAbAANADQAEwA1ABwAHAMAAgBtAA0ARgATAEcAbgAcAwACAG8ATQBwAE8AcQAJAAIJAAIAcgBzABgACwB0AA0AdQBjAGQADwB2ABEAEgATAHcAFQBmABwAIAMAAgB4AA0ARgATAEcACQACCQACAHkA'
..'cwAYAAsAdAANAHoAYwBkAA8AdgARABIAEwB7ABUAZgAcACIDAAIAfAANAEYAEwBHAH0AAgAAfgAkAAAJAAIJAAIAfwBzABgADQArAGMAZAARABIAEwAvABUAMQAXABgAgACBABwAJgEAAgCCAEsAJgQAAgCDAE0AhABPAIQAUwBUAIUAAgEAAgCGAIcAAgwAiAAMAIkA'
..'igCLAAwAjACKAI0AdACOAI8AkAAMAJEAigCSAHQAkwCPAJQAKgCVACwAlgACAwACAJcAmACZAJoAmwAJACsIAAIAnABzABgADQCdAGMAZAARABIAEwCeABUAnwAXABgAGQAsBAAaAKAAoQCiAKMApAClAKYAHAAsBAACADkADQCnAKgAqQATAKoAbgAsAwACAKsATQCn'
..'AE8AOgCsACsDAAIArQANAK4ArwCwALEAAgIAAgCxALIAswC0AAICAAIAtAC1ALYAlgACAwACALcAmAC4AJoAuQAJADMIAAIAnABzABgADQC6AGMAZAARABIAEwC7ABUAvAAXABgAGQA0BAAaAL0AoQC+AKMAvwClAKYAHAA0BAACAB0ADQDAAKgAwQATAMIAwwA0AgAC'
..'AMQAxQC8AG4ANAMAAgCrAE0AwABPAB4ACQAACgACAJwAcwAYAAsAyQANAMoAYwBkAA8AywARABIAEwDMABUAzQAXABgAGQA5BAAaAM4AoQDPAKMA0AClAKYA0QA5AwACANIA0wDUANUA1gDRADkDAAIA1wDTANgA1QDZANEAOQMAAgDaANMA2wDVAIEAHAA5BAACAG0A'
..'DQDcAKgA3QATAN4AhQAAAQACAN8A4AAAAQACAOEArAAAAwACAK0ADQDiAK8A4wCFAAIBAAIA5ADlAEIBAAIA5gDnAEMCAAIA6ADpAOoA5QBCAQACAOsA5wBFAgACAOwA6QDtAOUAQgEAAgDuAOcARwIAAgDvAOkA8ADxAEgCAAIA8gDFAPMA5wBHAgACAPQA6QD1APEA'
..'SgIAAgDyAMUAgQDlAEIBAAIA9gDnAEwCAAIA9wDpAPgA5QBCAQACAPkA5wBOAgACAPoA6QD7AOUAQgEAAgD8AOcAUAIAAgD9AOkA/gDlAEIBAAIA/wDnAFICAAIAAAHpAAEB5QBCAQACAAIB5wBUAgACAAMB6QD7AIUAAgEAAgDRAOAAVgEAAgAEAYUAAgEAAgAFAQYB'
..'AQsAAgAHAQgBEgBzABgACwAqAA0ACQEPACwAEQASABMACgEVAAsBFwAYAAwBZAAlAFkCAA0BgQAnAA4BhQBZAQACAA8BEwIHAAMUUQAKFFIAAxVRAAoVUgAgFlEAChZSACIXUQAKF1IAGRhRAAoYUgAcH1EAHB9SADkoUQAmKFIACi9RACwvUgAKOFEANDhSAAM=')
for _,obj in pairs(Objects) do
	obj.Parent = script or workspace
end

RunScripts()
